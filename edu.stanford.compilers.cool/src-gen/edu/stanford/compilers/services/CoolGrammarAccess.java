/*
* generated by Xtext
*/
package edu.stanford.compilers.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class CoolGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Program");
		private final Assignment cClassesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cClassesClass_ParserRuleCall_0 = (RuleCall)cClassesAssignment.eContents().get(0);
		
		//Program:
		//	classes+=Class_*;
		public ParserRule getRule() { return rule; }

		//classes+=Class_*
		public Assignment getClassesAssignment() { return cClassesAssignment; }

		//Class_
		public RuleCall getClassesClass_ParserRuleCall_0() { return cClassesClass_ParserRuleCall_0; }
	}

	public class Class_Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Class_");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cClassKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSYMBOLParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cInheritsKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cParentAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cParentTypeCrossReference_2_1_0 = (CrossReference)cParentAssignment_2_1.eContents().get(0);
		private final RuleCall cParentTypeIDTerminalRuleCall_2_1_0_1 = (RuleCall)cParentTypeCrossReference_2_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cFeaturesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cFeaturesFeature_ParserRuleCall_4_0 = (RuleCall)cFeaturesAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Class_:
		//	"class" name=SYMBOL ("inherits" parent=[Type])? "{" features+=Feature_* // filename : Symbol
		//	"};";
		public ParserRule getRule() { return rule; }

		//"class" name=SYMBOL ("inherits" parent=[Type])? "{" features+=Feature_* // filename : Symbol
		//"};"
		public Group getGroup() { return cGroup; }

		//"class"
		public Keyword getClassKeyword_0() { return cClassKeyword_0; }

		//name=SYMBOL
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//SYMBOL
		public RuleCall getNameSYMBOLParserRuleCall_1_0() { return cNameSYMBOLParserRuleCall_1_0; }

		//("inherits" parent=[Type])?
		public Group getGroup_2() { return cGroup_2; }

		//"inherits"
		public Keyword getInheritsKeyword_2_0() { return cInheritsKeyword_2_0; }

		//parent=[Type]
		public Assignment getParentAssignment_2_1() { return cParentAssignment_2_1; }

		//[Type]
		public CrossReference getParentTypeCrossReference_2_1_0() { return cParentTypeCrossReference_2_1_0; }

		//ID
		public RuleCall getParentTypeIDTerminalRuleCall_2_1_0_1() { return cParentTypeIDTerminalRuleCall_2_1_0_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//features+=Feature_*
		public Assignment getFeaturesAssignment_4() { return cFeaturesAssignment_4; }

		//Feature_
		public RuleCall getFeaturesFeature_ParserRuleCall_4_0() { return cFeaturesFeature_ParserRuleCall_4_0; }

		//// filename : Symbol
		//"};"
		public Keyword getRightCurlyBracketSemicolonKeyword_5() { return cRightCurlyBracketSemicolonKeyword_5; }
	}

	public class Feature_Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Feature_");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAttrParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMethodParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Feature_:
		//	Attr | Method;
		public ParserRule getRule() { return rule; }

		//Attr | Method
		public Alternatives getAlternatives() { return cAlternatives; }

		//Attr
		public RuleCall getAttrParserRuleCall_0() { return cAttrParserRuleCall_0; }

		//Method
		public RuleCall getMethodParserRuleCall_1() { return cMethodParserRuleCall_1; }
	}

	public class AttrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Attr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameSYMBOLParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cType_declAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cType_declTypeCrossReference_2_0 = (CrossReference)cType_declAssignment_2.eContents().get(0);
		private final RuleCall cType_declTypeIDTerminalRuleCall_2_0_1 = (RuleCall)cType_declTypeCrossReference_2_0.eContents().get(1);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLessThanSignHyphenMinusKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cInitAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cInitExpressionParserRuleCall_3_1_0 = (RuleCall)cInitAssignment_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Attr:
		//	name=SYMBOL ":" type_decl=[Type] ("<-" init=Expression)? ";";
		public ParserRule getRule() { return rule; }

		//name=SYMBOL ":" type_decl=[Type] ("<-" init=Expression)? ";"
		public Group getGroup() { return cGroup; }

		//name=SYMBOL
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//SYMBOL
		public RuleCall getNameSYMBOLParserRuleCall_0_0() { return cNameSYMBOLParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//type_decl=[Type]
		public Assignment getType_declAssignment_2() { return cType_declAssignment_2; }

		//[Type]
		public CrossReference getType_declTypeCrossReference_2_0() { return cType_declTypeCrossReference_2_0; }

		//ID
		public RuleCall getType_declTypeIDTerminalRuleCall_2_0_1() { return cType_declTypeIDTerminalRuleCall_2_0_1; }

		//("<-" init=Expression)?
		public Group getGroup_3() { return cGroup_3; }

		//"<-"
		public Keyword getLessThanSignHyphenMinusKeyword_3_0() { return cLessThanSignHyphenMinusKeyword_3_0; }

		//init=Expression
		public Assignment getInitAssignment_3_1() { return cInitAssignment_3_1; }

		//Expression
		public RuleCall getInitExpressionParserRuleCall_3_1_0() { return cInitExpressionParserRuleCall_3_1_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class MethodElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Method");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameSYMBOLParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cFormalsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cFormalsFormalParserRuleCall_2_0_0 = (RuleCall)cFormalsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cFormalsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cFormalsFormalParserRuleCall_2_1_1_0 = (RuleCall)cFormalsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cReturn_typeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final CrossReference cReturn_typeTypeCrossReference_5_0 = (CrossReference)cReturn_typeAssignment_5.eContents().get(0);
		private final RuleCall cReturn_typeTypeIDTerminalRuleCall_5_0_1 = (RuleCall)cReturn_typeTypeCrossReference_5_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cExprAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cExprExpressionParserRuleCall_7_0 = (RuleCall)cExprAssignment_7.eContents().get(0);
		private final Keyword cRightCurlyBracketSemicolonKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//Method:
		//	name=SYMBOL "(" (formals+=Formal ("," formals+=Formal)*)? ")" ":" return_type=[Type] "{" expr=Expression "};";
		public ParserRule getRule() { return rule; }

		//name=SYMBOL "(" (formals+=Formal ("," formals+=Formal)*)? ")" ":" return_type=[Type] "{" expr=Expression "};"
		public Group getGroup() { return cGroup; }

		//name=SYMBOL
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//SYMBOL
		public RuleCall getNameSYMBOLParserRuleCall_0_0() { return cNameSYMBOLParserRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(formals+=Formal ("," formals+=Formal)*)?
		public Group getGroup_2() { return cGroup_2; }

		//formals+=Formal
		public Assignment getFormalsAssignment_2_0() { return cFormalsAssignment_2_0; }

		//Formal
		public RuleCall getFormalsFormalParserRuleCall_2_0_0() { return cFormalsFormalParserRuleCall_2_0_0; }

		//("," formals+=Formal)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//formals+=Formal
		public Assignment getFormalsAssignment_2_1_1() { return cFormalsAssignment_2_1_1; }

		//Formal
		public RuleCall getFormalsFormalParserRuleCall_2_1_1_0() { return cFormalsFormalParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//":"
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }

		//return_type=[Type]
		public Assignment getReturn_typeAssignment_5() { return cReturn_typeAssignment_5; }

		//[Type]
		public CrossReference getReturn_typeTypeCrossReference_5_0() { return cReturn_typeTypeCrossReference_5_0; }

		//ID
		public RuleCall getReturn_typeTypeIDTerminalRuleCall_5_0_1() { return cReturn_typeTypeIDTerminalRuleCall_5_0_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_6() { return cLeftCurlyBracketKeyword_6; }

		//expr=Expression
		public Assignment getExprAssignment_7() { return cExprAssignment_7; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_7_0() { return cExprExpressionParserRuleCall_7_0; }

		//"};"
		public Keyword getRightCurlyBracketSemicolonKeyword_8() { return cRightCurlyBracketSemicolonKeyword_8; }
	}

	public class FormalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Formal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameSYMBOLParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cType_declAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cType_declTypeCrossReference_2_0 = (CrossReference)cType_declAssignment_2.eContents().get(0);
		private final RuleCall cType_declTypeIDTerminalRuleCall_2_0_1 = (RuleCall)cType_declTypeCrossReference_2_0.eContents().get(1);
		
		//Formal:
		//	name=SYMBOL ":" type_decl=[Type];
		public ParserRule getRule() { return rule; }

		//name=SYMBOL ":" type_decl=[Type]
		public Group getGroup() { return cGroup; }

		//name=SYMBOL
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//SYMBOL
		public RuleCall getNameSYMBOLParserRuleCall_0_0() { return cNameSYMBOLParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//type_decl=[Type]
		public Assignment getType_declAssignment_2() { return cType_declAssignment_2; }

		//[Type]
		public CrossReference getType_declTypeCrossReference_2_0() { return cType_declTypeCrossReference_2_0; }

		//ID
		public RuleCall getType_declTypeIDTerminalRuleCall_2_0_1() { return cType_declTypeIDTerminalRuleCall_2_0_1; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cDispatchExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		////precedence
		////.					static dispatch
		////@					instance dispatch
		////~					Unary integer complement
		////isvoid			Unary isvoid
		//// *  /				Multiplication
		////+  -				Addition
		////<=    <    =		Comparator
		////not				Negation
		////<-				Assignment
		//Expression:
		//	DispatchExpression;
		public ParserRule getRule() { return rule; }

		//DispatchExpression
		public RuleCall getDispatchExpressionParserRuleCall() { return cDispatchExpressionParserRuleCall; }
	}

	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConditionalExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLoopExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBlockExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLetExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cCaseExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cNewExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cIsvoidExpressionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cAssignmentExpressionParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cSelfTypeLiteralParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cIdentifierRefExpressionParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cLiteralParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cParenExpressionParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cNegationExpressionParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		private final RuleCall cIntegerCompositeParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		private final RuleCall cStaticDispatchExpressionParserRuleCall_14 = (RuleCall)cAlternatives.eContents().get(14);
		
		//PrimaryExpression returns Expression:
		//	ConditionalExpression | LoopExpression | BlockExpression | LetExpression | CaseExpression | NewExpression |
		//	IsvoidExpression | AssignmentExpression | SelfTypeLiteral | IdentifierRefExpression | Literal | ParenExpression |
		//	NegationExpression | IntegerComposite | StaticDispatchExpression;
		public ParserRule getRule() { return rule; }

		//ConditionalExpression | LoopExpression | BlockExpression | LetExpression | CaseExpression | NewExpression |
		//IsvoidExpression | AssignmentExpression | SelfTypeLiteral | IdentifierRefExpression | Literal | ParenExpression |
		//NegationExpression | IntegerComposite | StaticDispatchExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//ConditionalExpression
		public RuleCall getConditionalExpressionParserRuleCall_0() { return cConditionalExpressionParserRuleCall_0; }

		//LoopExpression
		public RuleCall getLoopExpressionParserRuleCall_1() { return cLoopExpressionParserRuleCall_1; }

		//BlockExpression
		public RuleCall getBlockExpressionParserRuleCall_2() { return cBlockExpressionParserRuleCall_2; }

		//LetExpression
		public RuleCall getLetExpressionParserRuleCall_3() { return cLetExpressionParserRuleCall_3; }

		//CaseExpression
		public RuleCall getCaseExpressionParserRuleCall_4() { return cCaseExpressionParserRuleCall_4; }

		//NewExpression
		public RuleCall getNewExpressionParserRuleCall_5() { return cNewExpressionParserRuleCall_5; }

		//IsvoidExpression
		public RuleCall getIsvoidExpressionParserRuleCall_6() { return cIsvoidExpressionParserRuleCall_6; }

		//AssignmentExpression
		public RuleCall getAssignmentExpressionParserRuleCall_7() { return cAssignmentExpressionParserRuleCall_7; }

		//SelfTypeLiteral
		public RuleCall getSelfTypeLiteralParserRuleCall_8() { return cSelfTypeLiteralParserRuleCall_8; }

		//IdentifierRefExpression
		public RuleCall getIdentifierRefExpressionParserRuleCall_9() { return cIdentifierRefExpressionParserRuleCall_9; }

		//Literal
		public RuleCall getLiteralParserRuleCall_10() { return cLiteralParserRuleCall_10; }

		//ParenExpression
		public RuleCall getParenExpressionParserRuleCall_11() { return cParenExpressionParserRuleCall_11; }

		//NegationExpression
		public RuleCall getNegationExpressionParserRuleCall_12() { return cNegationExpressionParserRuleCall_12; }

		//IntegerComposite
		public RuleCall getIntegerCompositeParserRuleCall_13() { return cIntegerCompositeParserRuleCall_13; }

		//StaticDispatchExpression
		public RuleCall getStaticDispatchExpressionParserRuleCall_14() { return cStaticDispatchExpressionParserRuleCall_14; }
	}

	public class SelfTypeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SelfTypeLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSelfTypeLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSelfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//SelfTypeLiteral:
		//	{SelfTypeLiteral} "self";
		public ParserRule getRule() { return rule; }

		//{SelfTypeLiteral} "self"
		public Group getGroup() { return cGroup; }

		//{SelfTypeLiteral}
		public Action getSelfTypeLiteralAction_0() { return cSelfTypeLiteralAction_0; }

		//"self"
		public Keyword getSelfKeyword_1() { return cSelfKeyword_1; }
	}

	public class IdentifierRefExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IdentifierRefExpression");
		private final Assignment cIdAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cIdIdentifiableElementCrossReference_0 = (CrossReference)cIdAssignment.eContents().get(0);
		private final RuleCall cIdIdentifiableElementIDTerminalRuleCall_0_1 = (RuleCall)cIdIdentifiableElementCrossReference_0.eContents().get(1);
		
		//IdentifierRefExpression:
		//	id=[IdentifiableElement];
		public ParserRule getRule() { return rule; }

		//id=[IdentifiableElement]
		public Assignment getIdAssignment() { return cIdAssignment; }

		//[IdentifiableElement]
		public CrossReference getIdIdentifiableElementCrossReference_0() { return cIdIdentifiableElementCrossReference_0; }

		//ID
		public RuleCall getIdIdentifiableElementIDTerminalRuleCall_0_1() { return cIdIdentifiableElementIDTerminalRuleCall_0_1; }
	}

	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumberLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBooleanLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Literal:
		//	NumberLiteral | StringLiteral | BooleanLiteral;
		public ParserRule getRule() { return rule; }

		//NumberLiteral | StringLiteral | BooleanLiteral
		public Alternatives getAlternatives() { return cAlternatives; }

		//NumberLiteral
		public RuleCall getNumberLiteralParserRuleCall_0() { return cNumberLiteralParserRuleCall_0; }

		//StringLiteral
		public RuleCall getStringLiteralParserRuleCall_1() { return cStringLiteralParserRuleCall_1; }

		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_2() { return cBooleanLiteralParserRuleCall_2; }
	}

	public class NumberLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumberLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//NumberLiteral:
		//	value=INT;
		public ParserRule getRule() { return rule; }

		//value=INT
		public Assignment getValueAssignment() { return cValueAssignment; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}

	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringLiteral:
		//	value=STRING;
		public ParserRule getRule() { return rule; }

		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}

	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBOOLEANParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//BooleanLiteral:
		//	value=BOOLEAN;
		public ParserRule getRule() { return rule; }

		//value=BOOLEAN
		public Assignment getValueAssignment() { return cValueAssignment; }

		//BOOLEAN
		public RuleCall getValueBOOLEANParserRuleCall_0() { return cValueBOOLEANParserRuleCall_0; }
	}

	public class ParenExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParenExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ParenExpression returns Expression:
		//	"(" expr=Expression ")";
		public ParserRule getRule() { return rule; }

		//"(" expr=Expression ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class AssignmentExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssignmentExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameSYMBOLParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLessThanSignHyphenMinusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//AssignmentExpression returns Expression:
		//	name=SYMBOL "<-" expr=Expression;
		public ParserRule getRule() { return rule; }

		//name=SYMBOL "<-" expr=Expression
		public Group getGroup() { return cGroup; }

		//name=SYMBOL
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//SYMBOL
		public RuleCall getNameSYMBOLParserRuleCall_0_0() { return cNameSYMBOLParserRuleCall_0_0; }

		//"<-"
		public Keyword getLessThanSignHyphenMinusKeyword_1() { return cLessThanSignHyphenMinusKeyword_1; }

		//expr=Expression
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_2_0() { return cExprExpressionParserRuleCall_2_0; }
	}

	public class NegationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NegationExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNotKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		
		//NegationExpression returns Expression:
		//	"not" expr=Expression;
		public ParserRule getRule() { return rule; }

		//"not" expr=Expression
		public Group getGroup() { return cGroup; }

		//"not"
		public Keyword getNotKeyword_0() { return cNotKeyword_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }
	}

	public class IntegerCompositeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntegerComposite");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTildeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		
		//IntegerComposite returns Expression:
		//	"~" expr=Expression;
		public ParserRule getRule() { return rule; }

		//"~" expr=Expression
		public Group getGroup() { return cGroup; }

		//"~"
		public Keyword getTildeKeyword_0() { return cTildeKeyword_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }
	}

	public class DispatchExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DispatchExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCompareExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cDispatchExpressionExprAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Group cGroup_1_0_0_1 = (Group)cGroup_1_0_0.eContents().get(1);
		private final Keyword cCommercialAtKeyword_1_0_0_1_0 = (Keyword)cGroup_1_0_0_1.eContents().get(0);
		private final Assignment cType_nameAssignment_1_0_0_1_1 = (Assignment)cGroup_1_0_0_1.eContents().get(1);
		private final CrossReference cType_nameTypeCrossReference_1_0_0_1_1_0 = (CrossReference)cType_nameAssignment_1_0_0_1_1.eContents().get(0);
		private final RuleCall cType_nameTypeIDTerminalRuleCall_1_0_0_1_1_0_1 = (RuleCall)cType_nameTypeCrossReference_1_0_0_1_1_0.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0_0_2 = (Keyword)cGroup_1_0_0.eContents().get(2);
		private final Assignment cRefAssignment_1_0_0_3 = (Assignment)cGroup_1_0_0.eContents().get(3);
		private final RuleCall cRefIdentifierRefExpressionParserRuleCall_1_0_0_3_0 = (RuleCall)cRefAssignment_1_0_0_3.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Assignment cActualAssignment_1_2_0 = (Assignment)cGroup_1_2.eContents().get(0);
		private final RuleCall cActualExpressionParserRuleCall_1_2_0_0 = (RuleCall)cActualAssignment_1_2_0.eContents().get(0);
		private final Group cGroup_1_2_1 = (Group)cGroup_1_2.eContents().get(1);
		private final Keyword cCommaKeyword_1_2_1_0 = (Keyword)cGroup_1_2_1.eContents().get(0);
		private final Assignment cActualAssignment_1_2_1_1 = (Assignment)cGroup_1_2_1.eContents().get(1);
		private final RuleCall cActualExpressionParserRuleCall_1_2_1_1_0 = (RuleCall)cActualAssignment_1_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//DispatchExpression returns Expression:
		//	CompareExpression (=> ({DispatchExpression.expr=current} ("@" type_name=[Type])? "." ref=IdentifierRefExpression) "("
		//	(actual+=Expression ("," actual+=Expression)*)? ")")?;
		public ParserRule getRule() { return rule; }

		//CompareExpression (=> ({DispatchExpression.expr=current} ("@" type_name=[Type])? "." ref=IdentifierRefExpression) "("
		//(actual+=Expression ("," actual+=Expression)*)? ")")?
		public Group getGroup() { return cGroup; }

		//CompareExpression
		public RuleCall getCompareExpressionParserRuleCall_0() { return cCompareExpressionParserRuleCall_0; }

		//(=> ({DispatchExpression.expr=current} ("@" type_name=[Type])? "." ref=IdentifierRefExpression) "(" (actual+=Expression
		//("," actual+=Expression)*)? ")")?
		public Group getGroup_1() { return cGroup_1; }

		//=> ({DispatchExpression.expr=current} ("@" type_name=[Type])? "." ref=IdentifierRefExpression)
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{DispatchExpression.expr=current} ("@" type_name=[Type])? "." ref=IdentifierRefExpression
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{DispatchExpression.expr=current}
		public Action getDispatchExpressionExprAction_1_0_0_0() { return cDispatchExpressionExprAction_1_0_0_0; }

		//("@" type_name=[Type])?
		public Group getGroup_1_0_0_1() { return cGroup_1_0_0_1; }

		//"@"
		public Keyword getCommercialAtKeyword_1_0_0_1_0() { return cCommercialAtKeyword_1_0_0_1_0; }

		//type_name=[Type]
		public Assignment getType_nameAssignment_1_0_0_1_1() { return cType_nameAssignment_1_0_0_1_1; }

		//[Type]
		public CrossReference getType_nameTypeCrossReference_1_0_0_1_1_0() { return cType_nameTypeCrossReference_1_0_0_1_1_0; }

		//ID
		public RuleCall getType_nameTypeIDTerminalRuleCall_1_0_0_1_1_0_1() { return cType_nameTypeIDTerminalRuleCall_1_0_0_1_1_0_1; }

		//"."
		public Keyword getFullStopKeyword_1_0_0_2() { return cFullStopKeyword_1_0_0_2; }

		//ref=IdentifierRefExpression
		public Assignment getRefAssignment_1_0_0_3() { return cRefAssignment_1_0_0_3; }

		//IdentifierRefExpression
		public RuleCall getRefIdentifierRefExpressionParserRuleCall_1_0_0_3_0() { return cRefIdentifierRefExpressionParserRuleCall_1_0_0_3_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//(actual+=Expression ("," actual+=Expression)*)?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//actual+=Expression
		public Assignment getActualAssignment_1_2_0() { return cActualAssignment_1_2_0; }

		//Expression
		public RuleCall getActualExpressionParserRuleCall_1_2_0_0() { return cActualExpressionParserRuleCall_1_2_0_0; }

		//("," actual+=Expression)*
		public Group getGroup_1_2_1() { return cGroup_1_2_1; }

		//","
		public Keyword getCommaKeyword_1_2_1_0() { return cCommaKeyword_1_2_1_0; }

		//actual+=Expression
		public Assignment getActualAssignment_1_2_1_1() { return cActualAssignment_1_2_1_1; }

		//Expression
		public RuleCall getActualExpressionParserRuleCall_1_2_1_1_0() { return cActualExpressionParserRuleCall_1_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}

	public class StaticDispatchExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StaticDispatchExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRefAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRefIdentifierRefExpressionParserRuleCall_0_0 = (RuleCall)cRefAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cActualAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cActualExpressionParserRuleCall_2_0_0 = (RuleCall)cActualAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cActualAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cActualExpressionParserRuleCall_2_1_1_0 = (RuleCall)cActualAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//StaticDispatchExpression returns Expression:
		//	ref=IdentifierRefExpression "(" (actual+=Expression ("," actual+=Expression)*)? ")";
		public ParserRule getRule() { return rule; }

		//ref=IdentifierRefExpression "(" (actual+=Expression ("," actual+=Expression)*)? ")"
		public Group getGroup() { return cGroup; }

		//ref=IdentifierRefExpression
		public Assignment getRefAssignment_0() { return cRefAssignment_0; }

		//IdentifierRefExpression
		public RuleCall getRefIdentifierRefExpressionParserRuleCall_0_0() { return cRefIdentifierRefExpressionParserRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(actual+=Expression ("," actual+=Expression)*)?
		public Group getGroup_2() { return cGroup_2; }

		//actual+=Expression
		public Assignment getActualAssignment_2_0() { return cActualAssignment_2_0; }

		//Expression
		public RuleCall getActualExpressionParserRuleCall_2_0_0() { return cActualExpressionParserRuleCall_2_0_0; }

		//("," actual+=Expression)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//actual+=Expression
		public Assignment getActualAssignment_2_1_1() { return cActualAssignment_2_1_1; }

		//Expression
		public RuleCall getActualExpressionParserRuleCall_2_1_1_0() { return cActualExpressionParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class ConditionalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConditionalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPredAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPredExpressionParserRuleCall_1_0 = (RuleCall)cPredAssignment_1.eContents().get(0);
		private final Keyword cThenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cThen_expAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cThen_expExpressionParserRuleCall_3_0 = (RuleCall)cThen_expAssignment_3.eContents().get(0);
		private final Keyword cElseKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cElse_expAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cElse_expExpressionParserRuleCall_5_0 = (RuleCall)cElse_expAssignment_5.eContents().get(0);
		private final Keyword cFiKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//ConditionalExpression returns Expression:
		//	"if" pred=Expression "then" then_exp=Expression "else" else_exp=Expression "fi";
		public ParserRule getRule() { return rule; }

		//"if" pred=Expression "then" then_exp=Expression "else" else_exp=Expression "fi"
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//pred=Expression
		public Assignment getPredAssignment_1() { return cPredAssignment_1; }

		//Expression
		public RuleCall getPredExpressionParserRuleCall_1_0() { return cPredExpressionParserRuleCall_1_0; }

		//"then"
		public Keyword getThenKeyword_2() { return cThenKeyword_2; }

		//then_exp=Expression
		public Assignment getThen_expAssignment_3() { return cThen_expAssignment_3; }

		//Expression
		public RuleCall getThen_expExpressionParserRuleCall_3_0() { return cThen_expExpressionParserRuleCall_3_0; }

		//"else"
		public Keyword getElseKeyword_4() { return cElseKeyword_4; }

		//else_exp=Expression
		public Assignment getElse_expAssignment_5() { return cElse_expAssignment_5; }

		//Expression
		public RuleCall getElse_expExpressionParserRuleCall_5_0() { return cElse_expExpressionParserRuleCall_5_0; }

		//"fi"
		public Keyword getFiKeyword_6() { return cFiKeyword_6; }
	}

	public class LoopExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LoopExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPredAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPredExpressionParserRuleCall_1_0 = (RuleCall)cPredAssignment_1.eContents().get(0);
		private final Keyword cLoopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyExpressionParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		private final Keyword cPoolKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//LoopExpression:
		//	"while" pred=Expression "loop" body=Expression "pool";
		public ParserRule getRule() { return rule; }

		//"while" pred=Expression "loop" body=Expression "pool"
		public Group getGroup() { return cGroup; }

		//"while"
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }

		//pred=Expression
		public Assignment getPredAssignment_1() { return cPredAssignment_1; }

		//Expression
		public RuleCall getPredExpressionParserRuleCall_1_0() { return cPredExpressionParserRuleCall_1_0; }

		//"loop"
		public Keyword getLoopKeyword_2() { return cLoopKeyword_2; }

		//body=Expression
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }

		//Expression
		public RuleCall getBodyExpressionParserRuleCall_3_0() { return cBodyExpressionParserRuleCall_3_0; }

		//"pool"
		public Keyword getPoolKeyword_4() { return cPoolKeyword_4; }
	}

	public class BlockExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BlockExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cBodyExpressionParserRuleCall_2_0_0 = (RuleCall)cBodyAssignment_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//BlockExpression:
		//	{BlockExpression} "{" (body+=Expression ";")* "}";
		public ParserRule getRule() { return rule; }

		//{BlockExpression} "{" (body+=Expression ";")* "}"
		public Group getGroup() { return cGroup; }

		//{BlockExpression}
		public Action getBlockExpressionAction_0() { return cBlockExpressionAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//(body+=Expression ";")*
		public Group getGroup_2() { return cGroup_2; }

		//body+=Expression
		public Assignment getBodyAssignment_2_0() { return cBodyAssignment_2_0; }

		//Expression
		public RuleCall getBodyExpressionParserRuleCall_2_0_0() { return cBodyExpressionParserRuleCall_2_0_0; }

		//";"
		public Keyword getSemicolonKeyword_2_1() { return cSemicolonKeyword_2_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class LetExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LetExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLetKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDeclarationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDeclarationLetDeclarationParserRuleCall_1_0 = (RuleCall)cDeclarationAssignment_1.eContents().get(0);
		private final Keyword cInKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyExpressionParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		
		//LetExpression:
		//	"let" declaration+=LetDeclaration+ "in" body=Expression;
		public ParserRule getRule() { return rule; }

		//"let" declaration+=LetDeclaration+ "in" body=Expression
		public Group getGroup() { return cGroup; }

		//"let"
		public Keyword getLetKeyword_0() { return cLetKeyword_0; }

		//declaration+=LetDeclaration+
		public Assignment getDeclarationAssignment_1() { return cDeclarationAssignment_1; }

		//LetDeclaration
		public RuleCall getDeclarationLetDeclarationParserRuleCall_1_0() { return cDeclarationLetDeclarationParserRuleCall_1_0; }

		//"in"
		public Keyword getInKeyword_2() { return cInKeyword_2; }

		//body=Expression
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }

		//Expression
		public RuleCall getBodyExpressionParserRuleCall_3_0() { return cBodyExpressionParserRuleCall_3_0; }
	}

	public class LetDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LetDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameSYMBOLParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cType_declAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cType_declTypeCrossReference_2_0 = (CrossReference)cType_declAssignment_2.eContents().get(0);
		private final RuleCall cType_declTypeIDTerminalRuleCall_2_0_1 = (RuleCall)cType_declTypeCrossReference_2_0.eContents().get(1);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLessThanSignHyphenMinusKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cInitAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cInitExpressionParserRuleCall_3_1_0 = (RuleCall)cInitAssignment_3_1.eContents().get(0);
		
		//LetDeclaration:
		//	name=SYMBOL ":" type_decl=[Type] ("<-" init=Expression)?;
		public ParserRule getRule() { return rule; }

		//name=SYMBOL ":" type_decl=[Type] ("<-" init=Expression)?
		public Group getGroup() { return cGroup; }

		//name=SYMBOL
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//SYMBOL
		public RuleCall getNameSYMBOLParserRuleCall_0_0() { return cNameSYMBOLParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//type_decl=[Type]
		public Assignment getType_declAssignment_2() { return cType_declAssignment_2; }

		//[Type]
		public CrossReference getType_declTypeCrossReference_2_0() { return cType_declTypeCrossReference_2_0; }

		//ID
		public RuleCall getType_declTypeIDTerminalRuleCall_2_0_1() { return cType_declTypeIDTerminalRuleCall_2_0_1; }

		//("<-" init=Expression)?
		public Group getGroup_3() { return cGroup_3; }

		//"<-"
		public Keyword getLessThanSignHyphenMinusKeyword_3_0() { return cLessThanSignHyphenMinusKeyword_3_0; }

		//init=Expression
		public Assignment getInitAssignment_3_1() { return cInitAssignment_3_1; }

		//Expression
		public RuleCall getInitExpressionParserRuleCall_3_1_0() { return cInitExpressionParserRuleCall_3_1_0; }
	}

	public class CaseExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CaseExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Keyword cOfKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCaseAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCaseCaseParserRuleCall_3_0 = (RuleCall)cCaseAssignment_3.eContents().get(0);
		private final Keyword cEsacKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//CaseExpression:
		//	"case" expr=Expression "of" case+=Case+ "esac";
		public ParserRule getRule() { return rule; }

		//"case" expr=Expression "of" case+=Case+ "esac"
		public Group getGroup() { return cGroup; }

		//"case"
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }

		//"of"
		public Keyword getOfKeyword_2() { return cOfKeyword_2; }

		//case+=Case+
		public Assignment getCaseAssignment_3() { return cCaseAssignment_3; }

		//Case
		public RuleCall getCaseCaseParserRuleCall_3_0() { return cCaseCaseParserRuleCall_3_0; }

		//"esac"
		public Keyword getEsacKeyword_4() { return cEsacKeyword_4; }
	}

	public class CaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Case");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameSYMBOLParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cType_declAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cType_declTypeCrossReference_2_0 = (CrossReference)cType_declAssignment_2.eContents().get(0);
		private final RuleCall cType_declTypeIDTerminalRuleCall_2_0_1 = (RuleCall)cType_declTypeCrossReference_2_0.eContents().get(1);
		private final Keyword cEqualsSignGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cExprExpressionParserRuleCall_4_0 = (RuleCall)cExprAssignment_4.eContents().get(0);
		
		//Case:
		//	name=SYMBOL ":" type_decl=[Type] "=>" expr=Expression;
		public ParserRule getRule() { return rule; }

		//name=SYMBOL ":" type_decl=[Type] "=>" expr=Expression
		public Group getGroup() { return cGroup; }

		//name=SYMBOL
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//SYMBOL
		public RuleCall getNameSYMBOLParserRuleCall_0_0() { return cNameSYMBOLParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//type_decl=[Type]
		public Assignment getType_declAssignment_2() { return cType_declAssignment_2; }

		//[Type]
		public CrossReference getType_declTypeCrossReference_2_0() { return cType_declTypeCrossReference_2_0; }

		//ID
		public RuleCall getType_declTypeIDTerminalRuleCall_2_0_1() { return cType_declTypeIDTerminalRuleCall_2_0_1; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_3() { return cEqualsSignGreaterThanSignKeyword_3; }

		//expr=Expression
		public Assignment getExprAssignment_4() { return cExprAssignment_4; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_4_0() { return cExprExpressionParserRuleCall_4_0; }
	}

	public class NewExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NewExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNewKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cType_nameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cType_nameTypeCrossReference_1_0 = (CrossReference)cType_nameAssignment_1.eContents().get(0);
		private final RuleCall cType_nameTypeIDTerminalRuleCall_1_0_1 = (RuleCall)cType_nameTypeCrossReference_1_0.eContents().get(1);
		
		//NewExpression:
		//	"new" type_name=[Type];
		public ParserRule getRule() { return rule; }

		//"new" type_name=[Type]
		public Group getGroup() { return cGroup; }

		//"new"
		public Keyword getNewKeyword_0() { return cNewKeyword_0; }

		//type_name=[Type]
		public Assignment getType_nameAssignment_1() { return cType_nameAssignment_1; }

		//[Type]
		public CrossReference getType_nameTypeCrossReference_1_0() { return cType_nameTypeCrossReference_1_0; }

		//ID
		public RuleCall getType_nameTypeIDTerminalRuleCall_1_0_1() { return cType_nameTypeIDTerminalRuleCall_1_0_1; }
	}

	public class IsvoidExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IsvoidExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsvoidKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		
		//IsvoidExpression returns Expression:
		//	"isvoid" expr=Expression;
		public ParserRule getRule() { return rule; }

		//"isvoid" expr=Expression
		public Group getGroup() { return cGroup; }

		//"isvoid"
		public Keyword getIsvoidKeyword_0() { return cIsvoidKeyword_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }
	}

	public class CompareExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompareExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditionExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cCompareExpressionLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOpCompareOperatorParserRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//CompareExpression returns Expression:
		//	AdditionExpression (=> ({CompareExpression.left=current} op=CompareOperator) right=Expression)?;
		public ParserRule getRule() { return rule; }

		//AdditionExpression (=> ({CompareExpression.left=current} op=CompareOperator) right=Expression)?
		public Group getGroup() { return cGroup; }

		//AdditionExpression
		public RuleCall getAdditionExpressionParserRuleCall_0() { return cAdditionExpressionParserRuleCall_0; }

		//(=> ({CompareExpression.left=current} op=CompareOperator) right=Expression)?
		public Group getGroup_1() { return cGroup_1; }

		//=> ({CompareExpression.left=current} op=CompareOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{CompareExpression.left=current} op=CompareOperator
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{CompareExpression.left=current}
		public Action getCompareExpressionLeftAction_1_0_0_0() { return cCompareExpressionLeftAction_1_0_0_0; }

		//op=CompareOperator
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }

		//CompareOperator
		public RuleCall getOpCompareOperatorParserRuleCall_1_0_0_1_0() { return cOpCompareOperatorParserRuleCall_1_0_0_1_0; }

		//right=Expression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Expression
		public RuleCall getRightExpressionParserRuleCall_1_1_0() { return cRightExpressionParserRuleCall_1_1_0; }
	}

	public class CompareOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompareOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//CompareOperator:
		//	"<" | "<=" | "=";
		public ParserRule getRule() { return rule; }

		//"<" | "<=" | "="
		public Alternatives getAlternatives() { return cAlternatives; }

		//"<"
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1() { return cLessThanSignEqualsSignKeyword_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }
	}

	public class AdditionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_0_0 = (Alternatives)cGroup_1_0.eContents().get(0);
		private final Group cGroup_1_0_0_0 = (Group)cAlternatives_1_0_0.eContents().get(0);
		private final Action cPlusOpAction_1_0_0_0_0 = (Action)cGroup_1_0_0_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0_0_1 = (Keyword)cGroup_1_0_0_0.eContents().get(1);
		private final Group cGroup_1_0_0_1 = (Group)cAlternatives_1_0_0.eContents().get(1);
		private final Action cMinusOpAction_1_0_0_1_0 = (Action)cGroup_1_0_0_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_0_1_1 = (Keyword)cGroup_1_0_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//AdditionExpression returns Expression:
		//	MultiplicationExpression (=> ({Plus.op=current} "+" | {Minus.op=current} "-") right=Expression)?;
		public ParserRule getRule() { return rule; }

		//MultiplicationExpression (=> ({Plus.op=current} "+" | {Minus.op=current} "-") right=Expression)?
		public Group getGroup() { return cGroup; }

		//MultiplicationExpression
		public RuleCall getMultiplicationExpressionParserRuleCall_0() { return cMultiplicationExpressionParserRuleCall_0; }

		//(=> ({Plus.op=current} "+" | {Minus.op=current} "-") right=Expression)?
		public Group getGroup_1() { return cGroup_1; }

		//=> ({Plus.op=current} "+" | {Minus.op=current} "-")
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{Plus.op=current} "+" | {Minus.op=current} "-"
		public Alternatives getAlternatives_1_0_0() { return cAlternatives_1_0_0; }

		//{Plus.op=current} "+"
		public Group getGroup_1_0_0_0() { return cGroup_1_0_0_0; }

		//{Plus.op=current}
		public Action getPlusOpAction_1_0_0_0_0() { return cPlusOpAction_1_0_0_0_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_0_0_0_1() { return cPlusSignKeyword_1_0_0_0_1; }

		//{Minus.op=current} "-"
		public Group getGroup_1_0_0_1() { return cGroup_1_0_0_1; }

		//{Minus.op=current}
		public Action getMinusOpAction_1_0_0_1_0() { return cMinusOpAction_1_0_0_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_0_0_1_1() { return cHyphenMinusKeyword_1_0_0_1_1; }

		//right=Expression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Expression
		public RuleCall getRightExpressionParserRuleCall_1_1_0() { return cRightExpressionParserRuleCall_1_1_0; }
	}

	public class MultiplicationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicationExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_0_0 = (Alternatives)cGroup_1_0.eContents().get(0);
		private final Group cGroup_1_0_0_0 = (Group)cAlternatives_1_0_0.eContents().get(0);
		private final Action cMultiOpAction_1_0_0_0_0 = (Action)cGroup_1_0_0_0.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_0_0_0_1 = (Keyword)cGroup_1_0_0_0.eContents().get(1);
		private final Group cGroup_1_0_0_1 = (Group)cAlternatives_1_0_0.eContents().get(1);
		private final Action cDivOpAction_1_0_0_1_0 = (Action)cGroup_1_0_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_0_0_1_1 = (Keyword)cGroup_1_0_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//MultiplicationExpression returns Expression:
		//	PrimaryExpression (=> ({Multi.op=current} "*" | {Div.op=current} "/") right=Expression)?;
		public ParserRule getRule() { return rule; }

		//PrimaryExpression (=> ({Multi.op=current} "*" | {Div.op=current} "/") right=Expression)?
		public Group getGroup() { return cGroup; }

		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }

		//(=> ({Multi.op=current} "*" | {Div.op=current} "/") right=Expression)?
		public Group getGroup_1() { return cGroup_1; }

		//=> ({Multi.op=current} "*" | {Div.op=current} "/")
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{Multi.op=current} "*" | {Div.op=current} "/"
		public Alternatives getAlternatives_1_0_0() { return cAlternatives_1_0_0; }

		//{Multi.op=current} "*"
		public Group getGroup_1_0_0_0() { return cGroup_1_0_0_0; }

		//{Multi.op=current}
		public Action getMultiOpAction_1_0_0_0_0() { return cMultiOpAction_1_0_0_0_0; }

		//"*"
		public Keyword getAsteriskKeyword_1_0_0_0_1() { return cAsteriskKeyword_1_0_0_0_1; }

		//{Div.op=current} "/"
		public Group getGroup_1_0_0_1() { return cGroup_1_0_0_1; }

		//{Div.op=current}
		public Action getDivOpAction_1_0_0_1_0() { return cDivOpAction_1_0_0_1_0; }

		//"/"
		public Keyword getSolidusKeyword_1_0_0_1_1() { return cSolidusKeyword_1_0_0_1_1; }

		//right=Expression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Expression
		public RuleCall getRightExpressionParserRuleCall_1_1_0() { return cRightExpressionParserRuleCall_1_1_0; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final RuleCall cClass_ParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Type:
		//	Class_;
		public ParserRule getRule() { return rule; }

		//Class_
		public RuleCall getClass_ParserRuleCall() { return cClass_ParserRuleCall; }
	}

	public class IdentifiableElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IdentifiableElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cClass_ParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFeature_ParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cFormalParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLetDeclarationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//IdentifiableElement:
		//	Class_ | Feature_ | Formal | LetDeclaration;
		public ParserRule getRule() { return rule; }

		//Class_ | Feature_ | Formal | LetDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//Class_
		public RuleCall getClass_ParserRuleCall_0() { return cClass_ParserRuleCall_0; }

		//Feature_
		public RuleCall getFeature_ParserRuleCall_1() { return cFeature_ParserRuleCall_1; }

		//Formal
		public RuleCall getFormalParserRuleCall_2() { return cFormalParserRuleCall_2; }

		//LetDeclaration
		public RuleCall getLetDeclarationParserRuleCall_3() { return cLetDeclarationParserRuleCall_3; }
	}

	public class BOOLEANElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLEAN");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//BOOLEAN:
		//	"true" | "false";
		public ParserRule getRule() { return rule; }

		//"true" | "false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"true"
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }

		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}

	public class SYMBOLElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SYMBOL");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cSelfKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//SYMBOL:
		//	ID | //	'class' | 
		//	//	'else' | 
		//	//	'false' |
		//	//	'' |
		//	//	'if' | 
		//	//	'in' |
		//	//	'inherits' | 
		//	//	'isvoid' |
		//	//	'let' |
		//	//	'loop' |
		//	//	'pool' |
		//	//	'then' |
		//	//	'while' |
		//	//	'case' |
		//	//	'esac' | 
		//	//	'new' | 
		//	//	'of' |
		//	//	'not' |
		//	//	'true' |
		//	"self";
		public ParserRule getRule() { return rule; }

		//ID | //	'class' | 
		////	'else' | 
		////	'false' |
		////	'' |
		////	'if' | 
		////	'in' |
		////	'inherits' | 
		////	'isvoid' |
		////	'let' |
		////	'loop' |
		////	'pool' |
		////	'then' |
		////	'while' |
		////	'case' |
		////	'esac' | 
		////	'new' | 
		////	'of' |
		////	'not' |
		////	'true' |
		//"self"
		public Alternatives getAlternatives() { return cAlternatives; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		////	'class' | 
		////	'else' | 
		////	'false' |
		////	'' |
		////	'if' | 
		////	'in' |
		////	'inherits' | 
		////	'isvoid' |
		////	'let' |
		////	'loop' |
		////	'pool' |
		////	'then' |
		////	'while' |
		////	'case' |
		////	'esac' | 
		////	'new' | 
		////	'of' |
		////	'not' |
		////	'true' |
		//"self"
		public Keyword getSelfKeyword_1() { return cSelfKeyword_1; }
	}
	
	
	private ProgramElements pProgram;
	private Class_Elements pClass_;
	private Feature_Elements pFeature_;
	private AttrElements pAttr;
	private MethodElements pMethod;
	private FormalElements pFormal;
	private ExpressionElements pExpression;
	private PrimaryExpressionElements pPrimaryExpression;
	private SelfTypeLiteralElements pSelfTypeLiteral;
	private IdentifierRefExpressionElements pIdentifierRefExpression;
	private LiteralElements pLiteral;
	private NumberLiteralElements pNumberLiteral;
	private StringLiteralElements pStringLiteral;
	private BooleanLiteralElements pBooleanLiteral;
	private ParenExpressionElements pParenExpression;
	private AssignmentExpressionElements pAssignmentExpression;
	private NegationExpressionElements pNegationExpression;
	private IntegerCompositeElements pIntegerComposite;
	private DispatchExpressionElements pDispatchExpression;
	private StaticDispatchExpressionElements pStaticDispatchExpression;
	private ConditionalExpressionElements pConditionalExpression;
	private LoopExpressionElements pLoopExpression;
	private BlockExpressionElements pBlockExpression;
	private LetExpressionElements pLetExpression;
	private LetDeclarationElements pLetDeclaration;
	private CaseExpressionElements pCaseExpression;
	private CaseElements pCase;
	private NewExpressionElements pNewExpression;
	private IsvoidExpressionElements pIsvoidExpression;
	private CompareExpressionElements pCompareExpression;
	private CompareOperatorElements pCompareOperator;
	private AdditionExpressionElements pAdditionExpression;
	private MultiplicationExpressionElements pMultiplicationExpression;
	private TypeElements pType;
	private IdentifiableElementElements pIdentifiableElement;
	private BOOLEANElements pBOOLEAN;
	private SYMBOLElements pSYMBOL;
	private TerminalRule tID;
	private TerminalRule tINT;
	private TerminalRule tSTRING;
	private TerminalRule tML_COMMENT;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tWS;
	private TerminalRule tANY_OTHER;
	
	private final Grammar grammar;

	@Inject
	public CoolGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("edu.stanford.compilers.Cool".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//Program:
	//	classes+=Class_*;
	public ProgramElements getProgramAccess() {
		return (pProgram != null) ? pProgram : (pProgram = new ProgramElements());
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}

	//Class_:
	//	"class" name=SYMBOL ("inherits" parent=[Type])? "{" features+=Feature_* // filename : Symbol
	//	"};";
	public Class_Elements getClass_Access() {
		return (pClass_ != null) ? pClass_ : (pClass_ = new Class_Elements());
	}
	
	public ParserRule getClass_Rule() {
		return getClass_Access().getRule();
	}

	//Feature_:
	//	Attr | Method;
	public Feature_Elements getFeature_Access() {
		return (pFeature_ != null) ? pFeature_ : (pFeature_ = new Feature_Elements());
	}
	
	public ParserRule getFeature_Rule() {
		return getFeature_Access().getRule();
	}

	//Attr:
	//	name=SYMBOL ":" type_decl=[Type] ("<-" init=Expression)? ";";
	public AttrElements getAttrAccess() {
		return (pAttr != null) ? pAttr : (pAttr = new AttrElements());
	}
	
	public ParserRule getAttrRule() {
		return getAttrAccess().getRule();
	}

	//Method:
	//	name=SYMBOL "(" (formals+=Formal ("," formals+=Formal)*)? ")" ":" return_type=[Type] "{" expr=Expression "};";
	public MethodElements getMethodAccess() {
		return (pMethod != null) ? pMethod : (pMethod = new MethodElements());
	}
	
	public ParserRule getMethodRule() {
		return getMethodAccess().getRule();
	}

	//Formal:
	//	name=SYMBOL ":" type_decl=[Type];
	public FormalElements getFormalAccess() {
		return (pFormal != null) ? pFormal : (pFormal = new FormalElements());
	}
	
	public ParserRule getFormalRule() {
		return getFormalAccess().getRule();
	}

	////precedence
	////.					static dispatch
	////@					instance dispatch
	////~					Unary integer complement
	////isvoid			Unary isvoid
	//// *  /				Multiplication
	////+  -				Addition
	////<=    <    =		Comparator
	////not				Negation
	////<-				Assignment
	//Expression:
	//	DispatchExpression;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//PrimaryExpression returns Expression:
	//	ConditionalExpression | LoopExpression | BlockExpression | LetExpression | CaseExpression | NewExpression |
	//	IsvoidExpression | AssignmentExpression | SelfTypeLiteral | IdentifierRefExpression | Literal | ParenExpression |
	//	NegationExpression | IntegerComposite | StaticDispatchExpression;
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return (pPrimaryExpression != null) ? pPrimaryExpression : (pPrimaryExpression = new PrimaryExpressionElements());
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	//SelfTypeLiteral:
	//	{SelfTypeLiteral} "self";
	public SelfTypeLiteralElements getSelfTypeLiteralAccess() {
		return (pSelfTypeLiteral != null) ? pSelfTypeLiteral : (pSelfTypeLiteral = new SelfTypeLiteralElements());
	}
	
	public ParserRule getSelfTypeLiteralRule() {
		return getSelfTypeLiteralAccess().getRule();
	}

	//IdentifierRefExpression:
	//	id=[IdentifiableElement];
	public IdentifierRefExpressionElements getIdentifierRefExpressionAccess() {
		return (pIdentifierRefExpression != null) ? pIdentifierRefExpression : (pIdentifierRefExpression = new IdentifierRefExpressionElements());
	}
	
	public ParserRule getIdentifierRefExpressionRule() {
		return getIdentifierRefExpressionAccess().getRule();
	}

	//Literal:
	//	NumberLiteral | StringLiteral | BooleanLiteral;
	public LiteralElements getLiteralAccess() {
		return (pLiteral != null) ? pLiteral : (pLiteral = new LiteralElements());
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	//NumberLiteral:
	//	value=INT;
	public NumberLiteralElements getNumberLiteralAccess() {
		return (pNumberLiteral != null) ? pNumberLiteral : (pNumberLiteral = new NumberLiteralElements());
	}
	
	public ParserRule getNumberLiteralRule() {
		return getNumberLiteralAccess().getRule();
	}

	//StringLiteral:
	//	value=STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return (pStringLiteral != null) ? pStringLiteral : (pStringLiteral = new StringLiteralElements());
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}

	//BooleanLiteral:
	//	value=BOOLEAN;
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return (pBooleanLiteral != null) ? pBooleanLiteral : (pBooleanLiteral = new BooleanLiteralElements());
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}

	//ParenExpression returns Expression:
	//	"(" expr=Expression ")";
	public ParenExpressionElements getParenExpressionAccess() {
		return (pParenExpression != null) ? pParenExpression : (pParenExpression = new ParenExpressionElements());
	}
	
	public ParserRule getParenExpressionRule() {
		return getParenExpressionAccess().getRule();
	}

	//AssignmentExpression returns Expression:
	//	name=SYMBOL "<-" expr=Expression;
	public AssignmentExpressionElements getAssignmentExpressionAccess() {
		return (pAssignmentExpression != null) ? pAssignmentExpression : (pAssignmentExpression = new AssignmentExpressionElements());
	}
	
	public ParserRule getAssignmentExpressionRule() {
		return getAssignmentExpressionAccess().getRule();
	}

	//NegationExpression returns Expression:
	//	"not" expr=Expression;
	public NegationExpressionElements getNegationExpressionAccess() {
		return (pNegationExpression != null) ? pNegationExpression : (pNegationExpression = new NegationExpressionElements());
	}
	
	public ParserRule getNegationExpressionRule() {
		return getNegationExpressionAccess().getRule();
	}

	//IntegerComposite returns Expression:
	//	"~" expr=Expression;
	public IntegerCompositeElements getIntegerCompositeAccess() {
		return (pIntegerComposite != null) ? pIntegerComposite : (pIntegerComposite = new IntegerCompositeElements());
	}
	
	public ParserRule getIntegerCompositeRule() {
		return getIntegerCompositeAccess().getRule();
	}

	//DispatchExpression returns Expression:
	//	CompareExpression (=> ({DispatchExpression.expr=current} ("@" type_name=[Type])? "." ref=IdentifierRefExpression) "("
	//	(actual+=Expression ("," actual+=Expression)*)? ")")?;
	public DispatchExpressionElements getDispatchExpressionAccess() {
		return (pDispatchExpression != null) ? pDispatchExpression : (pDispatchExpression = new DispatchExpressionElements());
	}
	
	public ParserRule getDispatchExpressionRule() {
		return getDispatchExpressionAccess().getRule();
	}

	//StaticDispatchExpression returns Expression:
	//	ref=IdentifierRefExpression "(" (actual+=Expression ("," actual+=Expression)*)? ")";
	public StaticDispatchExpressionElements getStaticDispatchExpressionAccess() {
		return (pStaticDispatchExpression != null) ? pStaticDispatchExpression : (pStaticDispatchExpression = new StaticDispatchExpressionElements());
	}
	
	public ParserRule getStaticDispatchExpressionRule() {
		return getStaticDispatchExpressionAccess().getRule();
	}

	//ConditionalExpression returns Expression:
	//	"if" pred=Expression "then" then_exp=Expression "else" else_exp=Expression "fi";
	public ConditionalExpressionElements getConditionalExpressionAccess() {
		return (pConditionalExpression != null) ? pConditionalExpression : (pConditionalExpression = new ConditionalExpressionElements());
	}
	
	public ParserRule getConditionalExpressionRule() {
		return getConditionalExpressionAccess().getRule();
	}

	//LoopExpression:
	//	"while" pred=Expression "loop" body=Expression "pool";
	public LoopExpressionElements getLoopExpressionAccess() {
		return (pLoopExpression != null) ? pLoopExpression : (pLoopExpression = new LoopExpressionElements());
	}
	
	public ParserRule getLoopExpressionRule() {
		return getLoopExpressionAccess().getRule();
	}

	//BlockExpression:
	//	{BlockExpression} "{" (body+=Expression ";")* "}";
	public BlockExpressionElements getBlockExpressionAccess() {
		return (pBlockExpression != null) ? pBlockExpression : (pBlockExpression = new BlockExpressionElements());
	}
	
	public ParserRule getBlockExpressionRule() {
		return getBlockExpressionAccess().getRule();
	}

	//LetExpression:
	//	"let" declaration+=LetDeclaration+ "in" body=Expression;
	public LetExpressionElements getLetExpressionAccess() {
		return (pLetExpression != null) ? pLetExpression : (pLetExpression = new LetExpressionElements());
	}
	
	public ParserRule getLetExpressionRule() {
		return getLetExpressionAccess().getRule();
	}

	//LetDeclaration:
	//	name=SYMBOL ":" type_decl=[Type] ("<-" init=Expression)?;
	public LetDeclarationElements getLetDeclarationAccess() {
		return (pLetDeclaration != null) ? pLetDeclaration : (pLetDeclaration = new LetDeclarationElements());
	}
	
	public ParserRule getLetDeclarationRule() {
		return getLetDeclarationAccess().getRule();
	}

	//CaseExpression:
	//	"case" expr=Expression "of" case+=Case+ "esac";
	public CaseExpressionElements getCaseExpressionAccess() {
		return (pCaseExpression != null) ? pCaseExpression : (pCaseExpression = new CaseExpressionElements());
	}
	
	public ParserRule getCaseExpressionRule() {
		return getCaseExpressionAccess().getRule();
	}

	//Case:
	//	name=SYMBOL ":" type_decl=[Type] "=>" expr=Expression;
	public CaseElements getCaseAccess() {
		return (pCase != null) ? pCase : (pCase = new CaseElements());
	}
	
	public ParserRule getCaseRule() {
		return getCaseAccess().getRule();
	}

	//NewExpression:
	//	"new" type_name=[Type];
	public NewExpressionElements getNewExpressionAccess() {
		return (pNewExpression != null) ? pNewExpression : (pNewExpression = new NewExpressionElements());
	}
	
	public ParserRule getNewExpressionRule() {
		return getNewExpressionAccess().getRule();
	}

	//IsvoidExpression returns Expression:
	//	"isvoid" expr=Expression;
	public IsvoidExpressionElements getIsvoidExpressionAccess() {
		return (pIsvoidExpression != null) ? pIsvoidExpression : (pIsvoidExpression = new IsvoidExpressionElements());
	}
	
	public ParserRule getIsvoidExpressionRule() {
		return getIsvoidExpressionAccess().getRule();
	}

	//CompareExpression returns Expression:
	//	AdditionExpression (=> ({CompareExpression.left=current} op=CompareOperator) right=Expression)?;
	public CompareExpressionElements getCompareExpressionAccess() {
		return (pCompareExpression != null) ? pCompareExpression : (pCompareExpression = new CompareExpressionElements());
	}
	
	public ParserRule getCompareExpressionRule() {
		return getCompareExpressionAccess().getRule();
	}

	//CompareOperator:
	//	"<" | "<=" | "=";
	public CompareOperatorElements getCompareOperatorAccess() {
		return (pCompareOperator != null) ? pCompareOperator : (pCompareOperator = new CompareOperatorElements());
	}
	
	public ParserRule getCompareOperatorRule() {
		return getCompareOperatorAccess().getRule();
	}

	//AdditionExpression returns Expression:
	//	MultiplicationExpression (=> ({Plus.op=current} "+" | {Minus.op=current} "-") right=Expression)?;
	public AdditionExpressionElements getAdditionExpressionAccess() {
		return (pAdditionExpression != null) ? pAdditionExpression : (pAdditionExpression = new AdditionExpressionElements());
	}
	
	public ParserRule getAdditionExpressionRule() {
		return getAdditionExpressionAccess().getRule();
	}

	//MultiplicationExpression returns Expression:
	//	PrimaryExpression (=> ({Multi.op=current} "*" | {Div.op=current} "/") right=Expression)?;
	public MultiplicationExpressionElements getMultiplicationExpressionAccess() {
		return (pMultiplicationExpression != null) ? pMultiplicationExpression : (pMultiplicationExpression = new MultiplicationExpressionElements());
	}
	
	public ParserRule getMultiplicationExpressionRule() {
		return getMultiplicationExpressionAccess().getRule();
	}

	//Type:
	//	Class_;
	public TypeElements getTypeAccess() {
		return (pType != null) ? pType : (pType = new TypeElements());
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//IdentifiableElement:
	//	Class_ | Feature_ | Formal | LetDeclaration;
	public IdentifiableElementElements getIdentifiableElementAccess() {
		return (pIdentifiableElement != null) ? pIdentifiableElement : (pIdentifiableElement = new IdentifiableElementElements());
	}
	
	public ParserRule getIdentifiableElementRule() {
		return getIdentifiableElementAccess().getRule();
	}

	//BOOLEAN:
	//	"true" | "false";
	public BOOLEANElements getBOOLEANAccess() {
		return (pBOOLEAN != null) ? pBOOLEAN : (pBOOLEAN = new BOOLEANElements());
	}
	
	public ParserRule getBOOLEANRule() {
		return getBOOLEANAccess().getRule();
	}

	//SYMBOL:
	//	ID | //	'class' | 
	//	//	'else' | 
	//	//	'false' |
	//	//	'' |
	//	//	'if' | 
	//	//	'in' |
	//	//	'inherits' | 
	//	//	'isvoid' |
	//	//	'let' |
	//	//	'loop' |
	//	//	'pool' |
	//	//	'then' |
	//	//	'while' |
	//	//	'case' |
	//	//	'esac' | 
	//	//	'new' | 
	//	//	'of' |
	//	//	'not' |
	//	//	'true' |
	//	"self";
	public SYMBOLElements getSYMBOLAccess() {
		return (pSYMBOL != null) ? pSYMBOL : (pSYMBOL = new SYMBOLElements());
	}
	
	public ParserRule getSYMBOLRule() {
		return getSYMBOLAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return (tID != null) ? tID : (tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID"));
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return (tSTRING != null) ? tSTRING : (tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING"));
	} 

	//terminal ML_COMMENT:
	//	"(*"->"*)";
	public TerminalRule getML_COMMENTRule() {
		return (tML_COMMENT != null) ? tML_COMMENT : (tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT"));
	} 

	//terminal SL_COMMENT:
	//	"--" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	////  -- Expressions
	////  constructor no_expr(): Expression;
	////  constructor object(name: Symbol): Expression;
	////end; terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return (tANY_OTHER != null) ? tANY_OTHER : (tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ANY_OTHER"));
	} 
}
