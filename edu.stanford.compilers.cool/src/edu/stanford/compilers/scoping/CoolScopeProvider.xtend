/*
 * generated by Xtext
 */
package edu.stanford.compilers.scoping

import com.google.inject.Inject
import edu.stanford.compilers.cool.Attr
import edu.stanford.compilers.cool.BooleanLiteral
import edu.stanford.compilers.cool.Class_
import edu.stanford.compilers.cool.CoolFactory
import edu.stanford.compilers.cool.CoolPackage
import edu.stanford.compilers.cool.DispatchExpression
import edu.stanford.compilers.cool.Expression
import edu.stanford.compilers.cool.Formal
import edu.stanford.compilers.cool.IdentifiableElement
import edu.stanford.compilers.cool.IdentifierRefExpression
import edu.stanford.compilers.cool.LetDeclaration
import edu.stanford.compilers.cool.LetExpression
import edu.stanford.compilers.cool.Method
import edu.stanford.compilers.cool.NewExpression
import edu.stanford.compilers.cool.NumberLiteral
import edu.stanford.compilers.cool.SelfTypeLiteral
import edu.stanford.compilers.cool.StringLiteral
import edu.stanford.compilers.cool.Type
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.eclipse.xtext.util.IResourceScopeCache

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it 
 *
 */
class CoolScopeProvider extends AbstractDeclarativeScopeProvider {
	
	@Inject
	private IResourceScopeCache cache	

	@Inject
	private extension GlobalTypeAccessor globalTypeAccessor

	override getScope(EObject context, EReference reference) {
		if(reference == CoolPackage.Literals.IDENTIFIER_REF_EXPRESSION__ID) {
			return collectVisibleIdentifiableElements(context, reference, <EObject>newArrayList, true)
		}
		return super.getScope(context, reference)
	}

	def private IScope collectVisibleIdentifiableElements(EObject context, EReference reference, List<EObject> eObjects, boolean respectType) {
		var parent = context.eContainer
		if(parent !== null) {
			val dispatchExpression = EcoreUtil2.getContainerOfType(parent, DispatchExpression)
			parent = if(dispatchExpression === null) {
				parent
			} else if(respectType) {
				if(context.eContainingFeature === CoolPackage.Literals.EXPRESSION__REF) {
					getType(dispatchExpression.expr, CoolPackage.Literals.IDENTIFIER_REF_EXPRESSION__ID)
				} else {
					parent
				}
			} else {
				parent
			}
			var letExpression = EcoreUtil2.getContainerOfType(parent, LetExpression)
			if(letExpression != null) {
				if(!eObjects.contains(letExpression)) eObjects.add(letExpression)
				collectVisibleIdentifiableElements(letExpression, reference, eObjects, respectType)
			} else {
				val method = EcoreUtil2.getContainerOfType(parent, Method)
				if(method !== null) {
					if(!eObjects.contains(method)) eObjects += method
					collectVisibleIdentifiableElements(method, reference, eObjects, respectType)
				} else {
					val class_ = EcoreUtil2.getContainerOfType(parent, Class_)
					if(class_ !== null) {
						if(!eObjects.contains(class_)) eObjects += class_
						var parentClass = class_.parent
						do {
							parentClass = 
								if (parentClass === null) {
									val objectClazz = class_.getObject(reference)
									if(objectClazz !== null && !eObjects.contains(objectClazz)) eObjects += objectClazz
									null
								} else if(parentClass instanceof Class_) { 
									if(parentClass !== null && !eObjects.contains(parentClass)) eObjects += parentClass
									parentClass.parent 
								} else { 
									null
								}
						} while(parentClass instanceof Class_)
					}
				}
			}
		}
		return createScope(context, reference, eObjects.reverse, IScope.NULLSCOPE)			
	}
	
	def private IScope createScope(EObject context, EReference reference, Iterable<EObject> eObjects, IScope parentScope) {
		val element = eObjects.head
		val scope = if(element instanceof LetExpression) {
			Scopes.scopeFor(element.declaration, parentScope)
		} else if(element instanceof Method) {
			Scopes.scopeFor(element.formals, parentScope)
		} else if(element instanceof Class_) {
			val features = <EObject>newArrayList
			features.addAll(element.features)
			if(element.parent === null) {
				val object = BuiltInTypes.object
				if(object instanceof Class_) {
					val existing = element.features.map[name]
					val featuresToAdd = object.features.filter[!existing.contains(it.name)]
					features.addAll(featuresToAdd)
				}
			}
			Scopes.scopeFor(features, parentScope)
		} else {
			null
		}
		if(scope !== null) createScope(context, reference, eObjects.tail, scope) else parentScope
	}
	
	def private resolveElement(IdentifierRefExpression expr, EReference reference) {
		val parent = expr
		val eObjects = <EObject>newArrayList
		val eObjects2 = <EObject>newArrayList
		collectVisibleIdentifiableElements(parent, reference, eObjects, false)
		for(element : eObjects) {
			if(element instanceof LetExpression) {
				eObjects2 += element.declaration
			} else if(element instanceof Method) {
				eObjects2.addAll(element.formals)
			} else if(element instanceof Class_) {
				val features = <EObject>newArrayList
				features.addAll(element.features)
				if(element.parent === null) {
					val object = BuiltInTypes.object
					if(object instanceof Class_) {
						val existing = element.features.map[name]
						val featuresToAdd = object.features.filter[!existing.contains(it.name)]
						features.addAll(featuresToAdd)
					}
				}
				eObjects2.addAll(element.features)
			}
		}
		val node = NodeModelUtils.getNode(expr)
		val text = node.text.trim
		val id = eObjects2.filter(IdentifiableElement).findFirst[name == text]
		id
	}
	
	def private Type getType(Expression expr, EReference reference) {
//	AssignmentExpression |	
//	StaticDispatchExpression

		if(expr.expr !== null) {
			return expr.expr.getType(reference)
		}
		if(expr.ref !== null) {
			return expr.ref.getType(reference)
		}
		//	NewExpression
		if(expr instanceof NewExpression) {
			if(!expr.type_name.eIsProxy) {
				return expr.type_name
			}
		}
		//	IdentifierRefExpression
		if(expr instanceof IdentifierRefExpression) {
			val type = cache.get('getType' -> expr, expr.eResource,
			[|
				val id = expr.resolveElement(reference)
				if(id !== null && !id.eIsProxy) {
					if(id instanceof Type) {
						return id
					} else if(id instanceof Formal) {
						return id.type_decl
					} else if(id instanceof LetDeclaration) {
						return id.type_decl
					} else if(id instanceof Method) {
						return id.return_type
					} else if(id instanceof Attr) {
						return id.type_decl
					}
				}
				null
			])
			if(type !== null) {
				return type
			}
		}
		if(expr instanceof NumberLiteral) {
			return expr.getInt(reference)
		}
		if(expr instanceof StringLiteral) {
			return expr.getString(reference)
		}
		if(expr instanceof BooleanLiteral) {
			return expr.getBool(reference)
		}
		if(expr instanceof SelfTypeLiteral) {
			val class_ = EcoreUtil2.getContainerOfType(expr, Class_)
			if(class_ !== null) {
				return class_
			}
		}
		return CoolFactory.eINSTANCE.createType
	}

	
}
