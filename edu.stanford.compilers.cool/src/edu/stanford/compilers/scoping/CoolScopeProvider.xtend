/*
 * generated by Xtext
 */
package edu.stanford.compilers.scoping

import com.google.inject.Inject
import edu.stanford.compilers.cool.AssignmentExpression
import edu.stanford.compilers.cool.Attr
import edu.stanford.compilers.cool.BooleanLiteral
import edu.stanford.compilers.cool.Case
import edu.stanford.compilers.cool.Class_
import edu.stanford.compilers.cool.CoolFactory
import edu.stanford.compilers.cool.CoolPackage
import edu.stanford.compilers.cool.DispatchExpression
import edu.stanford.compilers.cool.Expression
import edu.stanford.compilers.cool.Feature_
import edu.stanford.compilers.cool.Formal
import edu.stanford.compilers.cool.IdentifiableElement
import edu.stanford.compilers.cool.IdentifierRefExpression
import edu.stanford.compilers.cool.IntegerCompositeExpression
import edu.stanford.compilers.cool.LetDeclaration
import edu.stanford.compilers.cool.LetExpression
import edu.stanford.compilers.cool.Method
import edu.stanford.compilers.cool.NegationExpression
import edu.stanford.compilers.cool.NewExpression
import edu.stanford.compilers.cool.NumberLiteral
import edu.stanford.compilers.cool.ParenExpression
import edu.stanford.compilers.cool.SelfTypeLiteral
import edu.stanford.compilers.cool.StringLiteral
import edu.stanford.compilers.cool.Type
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.eclipse.xtext.util.IResourceScopeCache

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it 
 *
 */
class CoolScopeProvider extends AbstractDeclarativeScopeProvider {
	
	@Inject
	private IResourceScopeCache cache	

	@Inject
	private extension GlobalTypeAccessor globalTypeAccessor

	override getScope(EObject context, EReference reference) {
		if(reference == CoolPackage.Literals.IDENTIFIER_REF_EXPRESSION__ID) {
			return collectVisibleIdentifiableElements(context, reference, <EObject>newArrayList, true)
		}
		return super.getScope(context, reference)
	}

	def private IScope collectVisibleIdentifiableElements(EObject context, EReference reference, List<EObject> eObjects, boolean respectType) {
		var parent = context.eContainer
		if(parent !== null) {
			val dispatchExpression = EcoreUtil2.getContainerOfType(parent, DispatchExpression)
			parent = if(dispatchExpression === null) {
				parent
			} else if(respectType) {
				if(context.eContainingFeature === CoolPackage.Literals.DISPATCH_EXPRESSION__REF) {
					val expr = if(dispatchExpression.eContainer instanceof DispatchExpression) {
						 dispatchExpression.eContainer as DispatchExpression
					} else if(dispatchExpression.left === null) {
						val selfType = CoolFactory.eINSTANCE.createSelfTypeLiteral
						dispatchExpression.setLeft(selfType)
						dispatchExpression.left
					} else {
						dispatchExpression.left
					}
					getType(expr, CoolPackage.Literals.IDENTIFIER_REF_EXPRESSION__ID)
				} else if(context.eContainingFeature === CoolPackage.Literals.DISPATCH_EXPRESSION__CHAIN) {
					getType(dispatchExpression.chain, CoolPackage.Literals.IDENTIFIER_REF_EXPRESSION__ID)
				} else {
					parent
				}
			} else {
				parent
			}
			val aCase = EcoreUtil2.getContainerOfType(parent, Case)
			val letExpression = EcoreUtil2.getContainerOfType(parent, LetExpression)
			if(letExpression != null || aCase != null) {
				if(aCase != null && letExpression != null) {
					if(EcoreUtil2.isAncestor(aCase, letExpression)) {
						if(!eObjects.contains(letExpression)) eObjects.add(letExpression)
						return collectVisibleIdentifiableElements(letExpression, reference, eObjects, respectType)
					} else {
						if(!eObjects.contains(aCase)) eObjects.add(aCase)
						return collectVisibleIdentifiableElements(aCase, reference, eObjects, respectType)
					}
				} else if(aCase != null) {
					if(!eObjects.contains(aCase)) eObjects.add(aCase)
					return collectVisibleIdentifiableElements(aCase, reference, eObjects, respectType)
				} else {
					if(!eObjects.contains(letExpression)) eObjects.add(letExpression)
					return collectVisibleIdentifiableElements(letExpression, reference, eObjects, respectType)
				} 
			} else {
				val method = EcoreUtil2.getContainerOfType(parent, Method)
				if(method !== null) {
					if(!eObjects.contains(method)) eObjects += method
					return collectVisibleIdentifiableElements(method, reference, eObjects, respectType)
				} else {
					val class_ = EcoreUtil2.getContainerOfType(parent, Class_)
					if(class_ !== null) {
						if(!eObjects.contains(class_)) eObjects += class_
						var parentClass = class_.parent
						do {
							parentClass = 
								if (parentClass === null) {
									val objectClazz = class_.getObject(reference)
									if(objectClazz !== null && !eObjects.contains(objectClazz)) eObjects += objectClazz
									null
								} else if(parentClass instanceof Class_) { 
									if(parentClass !== null && !eObjects.contains(parentClass)) eObjects += parentClass
									parentClass.parent 
								} else { 
									null
								}
						} while(parentClass instanceof Class_)
					}
				}
			}
		}
		return createScope(context, reference, eObjects.reverse, IScope.NULLSCOPE)			
	}
	
	def private IScope createScope(EObject context, EReference reference, Iterable<EObject> eObjects, IScope parentScope) {
		val element = eObjects.head
		val scope = if(element instanceof Case) {
			Scopes.scopeFor(#[element as Case], parentScope)
		} else if(element instanceof LetExpression) {
			Scopes.scopeFor(element.declaration, parentScope)
		} else if(element instanceof Method) {
			Scopes.scopeFor(element.formals, parentScope)
		} else if(element instanceof Class_) {
			val features = <EObject>newArrayList
			features.addAll(element.features)
			if(element.parent === null) {
				val object = BuiltInTypes.object
				if(object instanceof Class_) {
					val existing = element.features.map[name]
					val featuresToAdd = object.features.filter[!existing.contains(it.name)]
					features.addAll(featuresToAdd)
				}
			}
			Scopes.scopeFor(features, parentScope)
		} else {
			null
		}
		if(scope !== null) createScope(context, reference, eObjects.tail, scope) else parentScope
	}
	
	def private resolveElement(IdentifierRefExpression expr, EReference reference) {
		val parent = expr
		val eObjects = <EObject>newArrayList
		val eObjects2 = <EObject>newArrayList
		collectVisibleIdentifiableElements(parent, reference, eObjects, false)
		for(element : eObjects) {
			if(element instanceof Case) {
				eObjects2 += element
			} else if(element instanceof LetExpression) {
				eObjects2 += element.declaration
			} else if(element instanceof Method) {
				eObjects2.addAll(element.formals)
			} else if(element instanceof Class_) {
				val features = <Feature_>newArrayList
				features.addAll(element.features)
				if(element.parent === null) {
					val object = BuiltInTypes.object
					if(object instanceof Class_) {
						val existing = features.map[name]
						val featuresToAdd = object.features.filter[!existing.contains(it.name)]
						features.addAll(featuresToAdd.toList)
					}
				}
				eObjects2.addAll(features)
			}
		}
		val node = NodeModelUtils.getNode(expr)
		val text = node.text.trim
		val id = eObjects2.filter(IdentifiableElement).findFirst[name == text]
		id
	}
	
	def private Type getType(Expression expr, EReference reference) {
//	AssignmentExpression |	
//	StaticDispatchExpression

		if(expr instanceof ParenExpression) {
			return expr.expr.getType(reference)
		}
		if(expr instanceof AssignmentExpression) {
			return expr.expr.getType(reference)
		}
		if(expr instanceof NegationExpression) {
			return expr.expr.getType(reference)
		}
		if(expr instanceof IntegerCompositeExpression) {
			return expr.expr.getType(reference)
		}
		if(expr instanceof Case) {
			return expr.expr.getType(reference)
		}
		if(expr instanceof NewExpression) {
			if(!expr.type_name.eIsProxy) {
				return expr.type_name
			}
		}
		if(expr instanceof DispatchExpression) {
			if(expr.ref !== null) {
				return expr.ref.getType(reference)
			} else {
				return expr.getContainingClassAsType
			}
		}
		//	IdentifierRefExpression
		if(expr instanceof IdentifierRefExpression) {
			val type = cache.get('getType' -> expr, expr.eResource,
			[|
				val id = expr.resolveElement(reference)
				if(id !== null && !id.eIsProxy) {
					val t = if(id instanceof Type) {
						id
					} else if(id instanceof Formal) {
						id.type_decl
					} else if(id instanceof Case) {
						id.type_decl
					} else if(id instanceof LetDeclaration) {
						id.type_decl
					} else if(id instanceof Method) {
						id.return_type
					} else if(id instanceof Attr) {
						id.type_decl
					}
					if(t instanceof Class_) {
						if((t as Class_).name == "SELF_TYPE") {
							return id.getContainingClassAsType
						}
					}
					return t
				}
				null
			])
			if(type !== null) {
				return type
			}
		}
		if(expr instanceof NumberLiteral) {
			return BuiltInTypes.int
		}
		if(expr instanceof StringLiteral) {
			return BuiltInTypes.string
		}
		if(expr instanceof BooleanLiteral) {
			return BuiltInTypes.bool
		}
		if(expr instanceof SelfTypeLiteral) {
			return expr.getContainingClassAsType
		}
		return CoolFactory.eINSTANCE.createType
	}
	
	def private Class_ getContainingClassAsType(EObject eo) {
		val class_ = EcoreUtil2.getContainerOfType(eo, Class_)
		if(class_ !== null) {
			return class_
		}
	}
}
