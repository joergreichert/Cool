/*
 * generated by Xtext
 */
package edu.stanford.compilers.scoping

import com.google.inject.Inject
import edu.stanford.compilers.cool.Attr
import edu.stanford.compilers.cool.BooleanLiteral
import edu.stanford.compilers.cool.Class_
import edu.stanford.compilers.cool.CoolFactory
import edu.stanford.compilers.cool.CoolPackage
import edu.stanford.compilers.cool.DispatchExpression
import edu.stanford.compilers.cool.Expression
import edu.stanford.compilers.cool.Formal
import edu.stanford.compilers.cool.IdentifierRefExpression
import edu.stanford.compilers.cool.LetDeclaration
import edu.stanford.compilers.cool.LetExpression
import edu.stanford.compilers.cool.Method
import edu.stanford.compilers.cool.NewExpression
import edu.stanford.compilers.cool.NumberLiteral
import edu.stanford.compilers.cool.StringLiteral
import edu.stanford.compilers.cool.Type
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.scoping.IGlobalScopeProvider
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.eclipse.xtext.util.IResourceScopeCache

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it 
 *
 */
class CoolScopeProvider extends AbstractDeclarativeScopeProvider {
	@Inject 
	private IGlobalScopeProvider globalScopeProvider
	
	@Inject
	private IResourceScopeCache cache	

	override getScope(EObject context, EReference reference) {
		if(reference == CoolPackage.Literals.IDENTIFIER_REF_EXPRESSION__ID) {
			return collectVisibleIdentifiableElements(context, <EObject>newArrayList)
		}
		return super.getScope(context, reference)
	}

	def private IScope collectVisibleIdentifiableElements(EObject context, List<EObject> eObjects) {
		var parent = context.eContainer
		if(parent !== null) {
			val dispatchExpression = EcoreUtil2.getContainerOfType(parent, DispatchExpression)
			parent = if(dispatchExpression === null) {
				parent
			} else {
				getType(dispatchExpression.expr)
			}
			var letExpression = EcoreUtil2.getContainerOfType(parent, LetExpression)
			if(letExpression != null) {
				eObjects.addAll(letExpression)
				collectVisibleIdentifiableElements(letExpression, eObjects)
			} else {
				val method = EcoreUtil2.getContainerOfType(parent, Method)
				if(method !== null) {
					eObjects += method
					collectVisibleIdentifiableElements(method, eObjects)
				} else {
					val class_ = EcoreUtil2.getContainerOfType(parent, Class_)
					if(class_ !== null) {
						eObjects += class_
						var parentClass = class_.parent
						while(parentClass !== null) {
							eObjects += parentClass
							parentClass = if(parentClass instanceof Class_) parentClass.parent else null
						}
					}
				}
			}
		}
		return createScope(eObjects.reverse, IScope.NULLSCOPE)			
	}
	
	def private IScope createScope(Iterable<EObject> eObjects, IScope parentScope) {
		val element = eObjects.head
		val scope = if(element instanceof LetExpression) {
			Scopes.scopeFor(element.declaration, parentScope)
		} else if(element instanceof Method) {
			Scopes.scopeFor(element.formals, parentScope)
		} else if(element instanceof Class_) {
			Scopes.scopeFor(element.features, parentScope)
		} else {
			null
		}
		if(scope !== null) createScope(eObjects.tail, scope) else parentScope
	}
	
	def private Type getType(Expression expr) {
//	AssignmentExpression |	
//	StaticDispatchExpression

//		if(expr.expr !== null) {
//			return expr.expr.getType
//		}
//		if(expr.ref !== null) {
//			return expr.ref.getType
//		}
		//	NewExpression
		if(expr instanceof NewExpression) {
			if(!expr.type_name.eIsProxy) {
				return expr.type_name
			}
		}
		//	IdentifierRefExpression
		if(expr instanceof IdentifierRefExpression) {
			val type = cache.get('getType' -> expr, expr.eResource,
			[|
//				val id = expr.id
//				if(!id.eIsProxy) {
//					if(id instanceof Type) {
//						return id
//					} else if(id instanceof Formal) {
//						return id.type_decl
//					} else if(id instanceof LetDeclaration) {
//						return id.type_decl
//					} else if(id instanceof Method) {
//						return id.return_type
//					} else if(id instanceof Attr) {
//						return id.type_decl
//					}
//				}
				null
			])
			if(type !== null) {
				return type
			}
		}
		if(expr instanceof NumberLiteral) {
			return expr.getInt
		}
		if(expr instanceof StringLiteral) {
			return expr.getString
		}
		if(expr instanceof BooleanLiteral) {
			return expr.getBool
		}
//		if(expr instanceof SelfTypeLiteral) {
//			val class_ = EcoreUtil2.getContainerOfType(expr, Class_)
//			if(class_ !== null) {
//				return class_
//			}
//		}
		return CoolFactory.eINSTANCE.createType
	}
	
	def private getBool(Expression expr) {
		expr.getGlobalType("Bool")
	}
	
	def private getString(Expression expr) {
		expr.getGlobalType("String")
	}	
	
	def private getInt(Expression expr) {
		expr.getGlobalType("Int")
	}	
	
	def private getGlobalType(Expression expr, String typeName) {
		return globalScopeProvider.getScope(expr.eResource, null) [
			return typeName.equals(it.getName())
		].allElements.filter(Type).head 
	}	
}
